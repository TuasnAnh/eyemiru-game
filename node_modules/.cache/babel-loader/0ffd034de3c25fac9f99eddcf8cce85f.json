{"ast":null,"code":"import createOrthoCamera from './orthoCamera';\nimport resizeCanvas from './resizeCanvas';\nconst defaultOptions = {\n  autoUpdate: true,\n  pixelRatio: undefined,\n  crop: true\n};\nexport default ((canvas, width, height, options) => {\n  options = { ...defaultOptions,\n    ...options\n  };\n  const gl = canvas.getContext('webgl');\n  const additionalCameras = [];\n  let {\n    autoUpdate,\n    pixelRatio,\n    crop\n  } = options;\n  pixelRatio = pixelRatio || window.devicePixelRatio || 1;\n  const viewportInfo = {\n    pixelRatio,\n    x: 0,\n    y: 0,\n    width,\n    height\n  };\n  let resizeHandler;\n  const [vWidth, vHeight] = resizeCanvas(canvas, pixelRatio);\n  const camera = createOrthoCamera(width, height, vWidth, vHeight);\n\n  if (autoUpdate) {\n    resizeHandler = e => {\n      viewportObject.update();\n    };\n\n    window.addEventListener('resize', resizeHandler);\n  }\n\n  const viewportObject = {\n    getViewportInfo() {\n      return viewportInfo;\n    },\n\n    getCamera() {\n      return camera;\n    },\n\n    addCamera(camera) {\n      additionalCameras.push(camera);\n    },\n\n    getContext() {\n      return gl;\n    },\n\n    update() {\n      let [vWidth, vHeight] = resizeCanvas(canvas, pixelRatio);\n      const ratio = width / height;\n      const vRatio = vWidth / vHeight;\n      let displayWidth, displayHeight;\n\n      if (ratio < vRatio) {\n        displayHeight = vHeight;\n        displayWidth = vHeight * ratio;\n      } else {\n        displayWidth = vWidth;\n        displayHeight = vWidth / ratio;\n      }\n\n      const displayX = (vWidth - displayWidth) / 2;\n      const displayY = (vHeight - displayHeight) / 2;\n      viewportInfo.x = displayX;\n      viewportInfo.y = displayY;\n      viewportInfo.width = displayWidth;\n      viewportInfo.height = displayHeight;\n      gl.viewport(displayX, displayY, displayWidth, displayHeight);\n      camera.resize(width, height, displayWidth, displayHeight);\n\n      for (let camera of additionalCameras) {\n        camera.resize(width, height, displayWidth, displayHeight);\n      }\n    },\n\n    cleanUp() {\n      if (resizeHandler) {\n        window.removeEventListener('resize', resizeHandler);\n      }\n    }\n\n  };\n  autoUpdate && viewportObject.update();\n  return viewportObject;\n});","map":{"version":3,"sources":["E:/game-project/eyemiru/node_modules/gdxjs/lib/createViewport.js"],"names":["createOrthoCamera","resizeCanvas","defaultOptions","autoUpdate","pixelRatio","undefined","crop","canvas","width","height","options","gl","getContext","additionalCameras","window","devicePixelRatio","viewportInfo","x","y","resizeHandler","vWidth","vHeight","camera","e","viewportObject","update","addEventListener","getViewportInfo","getCamera","addCamera","push","ratio","vRatio","displayWidth","displayHeight","displayX","displayY","viewport","resize","cleanUp","removeEventListener"],"mappings":"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","sourcesContent":["import createOrthoCamera from './orthoCamera';\nimport resizeCanvas from './resizeCanvas';\nconst defaultOptions = {\n  autoUpdate: true,\n  pixelRatio: undefined,\n  crop: true\n};\nexport default ((canvas, width, height, options) => {\n  options = { ...defaultOptions,\n    ...options\n  };\n  const gl = canvas.getContext('webgl');\n  const additionalCameras = [];\n  let {\n    autoUpdate,\n    pixelRatio,\n    crop\n  } = options;\n  pixelRatio = pixelRatio || window.devicePixelRatio || 1;\n  const viewportInfo = {\n    pixelRatio,\n    x: 0,\n    y: 0,\n    width,\n    height\n  };\n  let resizeHandler;\n  const [vWidth, vHeight] = resizeCanvas(canvas, pixelRatio);\n  const camera = createOrthoCamera(width, height, vWidth, vHeight);\n\n  if (autoUpdate) {\n    resizeHandler = e => {\n      viewportObject.update();\n    };\n\n    window.addEventListener('resize', resizeHandler);\n  }\n\n  const viewportObject = {\n    getViewportInfo() {\n      return viewportInfo;\n    },\n\n    getCamera() {\n      return camera;\n    },\n\n    addCamera(camera) {\n      additionalCameras.push(camera);\n    },\n\n    getContext() {\n      return gl;\n    },\n\n    update() {\n      let [vWidth, vHeight] = resizeCanvas(canvas, pixelRatio);\n      const ratio = width / height;\n      const vRatio = vWidth / vHeight;\n      let displayWidth, displayHeight;\n\n      if (ratio < vRatio) {\n        displayHeight = vHeight;\n        displayWidth = vHeight * ratio;\n      } else {\n        displayWidth = vWidth;\n        displayHeight = vWidth / ratio;\n      }\n\n      const displayX = (vWidth - displayWidth) / 2;\n      const displayY = (vHeight - displayHeight) / 2;\n      viewportInfo.x = displayX;\n      viewportInfo.y = displayY;\n      viewportInfo.width = displayWidth;\n      viewportInfo.height = displayHeight;\n      gl.viewport(displayX, displayY, displayWidth, displayHeight);\n      camera.resize(width, height, displayWidth, displayHeight);\n\n      for (let camera of additionalCameras) {\n        camera.resize(width, height, displayWidth, displayHeight);\n      }\n    },\n\n    cleanUp() {\n      if (resizeHandler) {\n        window.removeEventListener('resize', resizeHandler);\n      }\n    }\n\n  };\n  autoUpdate && viewportObject.update();\n  return viewportObject;\n});"]},"metadata":{},"sourceType":"module"}