{"ast":null,"code":"const shuffle = array => {\n  array.sort(() => Math.random() - 0.5);\n};\n\nconst getDelayBaseOnDifficulty = difficulty => {\n  if (difficulty >= 1 && difficulty <= 3) {\n    return 1;\n  } else if (difficulty >= 4 && difficulty <= 6) {\n    return 2;\n  } else if (difficulty >= 7 && difficulty <= 9) {\n    return 1.5;\n  } else {\n    return 1;\n  }\n};\n\nconst getShootTypeBaseOnDifficulty = difficulty => {\n  if (difficulty >= 1 && difficulty <= 2) {\n    return {\n      minNumber: 0,\n      maxNumber: 2\n    };\n  } else if (difficulty >= 3 && difficulty <= 7) {\n    return {\n      minNumber: 0,\n      maxNumber: 3\n    };\n  } else {\n    return {\n      minNumber: 0,\n      maxNumber: 5\n    };\n  }\n};\n\nconst getPattern = (number, width, height) => {\n  let timer = 0;\n  let x = [];\n\n  if (number === 0) {\n    timer = [0];\n    x = [Math.random() * (width * 0.8 - width * 0.15) + width * 0.15];\n  }\n\n  return {\n    timer,\n    x\n  };\n};\n\nconst createProductSpawnSystem = () => {\n  let delayTime = 2;\n  let pattern;\n  let timer = 0;\n  let index = 0;\n  let xIndex = 0;\n  return {\n    update(delta, worldState, {\n      width,\n      height,\n      productTex,\n      fakeProductTex\n    }) {\n      const {\n        difficulty,\n        products\n      } = worldState;\n\n      if (worldState.stateTime > delayTime && pattern === undefined) {\n        const {\n          minNumber,\n          maxNumber\n        } = getShootTypeBaseOnDifficulty(difficulty); // pattern = getPattern(\n        //   Math.round(Math.random() * (maxNumber - minNumber) + minNumber),\n        //   width,\n        //   height\n        // );\n\n        pattern = getPattern(0, width, height);\n        timer = worldState.stateTime + pattern.timer[index];\n      }\n\n      if (worldState.stateTime > delayTime && worldState.stateTime > timer && pattern !== undefined) {\n        index = Math.min(index += 1, pattern.timer.length);\n        timer = worldState.stateTime + pattern.timer[index]; // loop to check every same timer products\n\n        let loop = 1;\n        let tmpIndex = index - 1;\n\n        while (true) {\n          if (pattern.timer[tmpIndex] === pattern.timer[tmpIndex + 1] && tmpIndex < pattern.timer.length) {\n            tmpIndex = Math.min(tmpIndex += 1, pattern.timer.length);\n            loop += 1;\n          } else {\n            break;\n          }\n        } // add to products list\n\n\n        for (let i = 0; i < loop; i++) {\n          if (i > 0) {\n            index = Math.min(index += 1, pattern.timer.length);\n          }\n\n          timer = worldState.stateTime + pattern.timer[index]; // TODO: get random product\n\n          let isFake = true;\n          let randomProduct = Math.floor(Math.random() * fakeProductTex.length);\n\n          if (Math.random() > 0.3) {\n            isFake = false;\n            randomProduct = Math.floor(Math.random() * productTex.length);\n          }\n\n          products.push({\n            // type: randomProduct,\n            type: 2,\n            // isFake,\n            stateTime: 0,\n            x: pattern.x[xIndex],\n            y: -height / 8,\n            speedY: 0\n          });\n          xIndex = Math.min(xIndex += 1, pattern.x.length - 1);\n        }\n\n        if (index === pattern.timer.length) {\n          delayTime = worldState.stateTime + getDelayBaseOnDifficulty(difficulty);\n          index = 0;\n          xIndex = 0;\n          pattern = undefined;\n        }\n      }\n    }\n\n  };\n};\n\nexport default createProductSpawnSystem;","map":{"version":3,"sources":["E:/game-project/eyemiru/src/systems/ProductSpawnSystem.js"],"names":["shuffle","array","sort","Math","random","getDelayBaseOnDifficulty","difficulty","getShootTypeBaseOnDifficulty","minNumber","maxNumber","getPattern","number","width","height","timer","x","createProductSpawnSystem","delayTime","pattern","index","xIndex","update","delta","worldState","productTex","fakeProductTex","products","stateTime","undefined","min","length","loop","tmpIndex","i","isFake","randomProduct","floor","push","type","y","speedY"],"mappings":"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","sourcesContent":["const shuffle = (array) => {\r\n  array.sort(() => Math.random() - 0.5);\r\n};\r\n\r\nconst getDelayBaseOnDifficulty = (difficulty) => {\r\n  if (difficulty >= 1 && difficulty <= 3) {\r\n    return 1;\r\n  } else if (difficulty >= 4 && difficulty <= 6) {\r\n    return 2;\r\n  } else if (difficulty >= 7 && difficulty <= 9) {\r\n    return 1.5;\r\n  } else {\r\n    return 1;\r\n  }\r\n};\r\n\r\nconst getShootTypeBaseOnDifficulty = (difficulty) => {\r\n  if (difficulty >= 1 && difficulty <= 2) {\r\n    return { minNumber: 0, maxNumber: 2 };\r\n  } else if (difficulty >= 3 && difficulty <= 7) {\r\n    return { minNumber: 0, maxNumber: 3 };\r\n  } else {\r\n    return { minNumber: 0, maxNumber: 5 };\r\n  }\r\n};\r\n\r\nconst getPattern = (number, width, height) => {\r\n  let timer = 0;\r\n  let x = [];\r\n\r\n  if (number === 0) {\r\n    timer = [0];\r\n    x = [Math.random() * (width * 0.8 - width * 0.15) + width * 0.15];\r\n  }\r\n\r\n  return { timer, x };\r\n};\r\n\r\nconst createProductSpawnSystem = () => {\r\n  let delayTime = 2;\r\n  let pattern;\r\n  let timer = 0;\r\n  let index = 0;\r\n  let xIndex = 0;\r\n  return {\r\n    update(delta, worldState, { width, height, productTex, fakeProductTex }) {\r\n      const { difficulty, products } = worldState;\r\n\r\n      if (worldState.stateTime > delayTime && pattern === undefined) {\r\n        const { minNumber, maxNumber } = getShootTypeBaseOnDifficulty(\r\n          difficulty\r\n        );\r\n        // pattern = getPattern(\r\n        //   Math.round(Math.random() * (maxNumber - minNumber) + minNumber),\r\n        //   width,\r\n        //   height\r\n        // );\r\n        pattern = getPattern(0, width, height);\r\n        timer = worldState.stateTime + pattern.timer[index];\r\n      }\r\n\r\n      if (\r\n        worldState.stateTime > delayTime &&\r\n        worldState.stateTime > timer &&\r\n        pattern !== undefined\r\n      ) {\r\n        index = Math.min((index += 1), pattern.timer.length);\r\n        timer = worldState.stateTime + pattern.timer[index];\r\n\r\n        // loop to check every same timer products\r\n        let loop = 1;\r\n        let tmpIndex = index - 1;\r\n        while (true) {\r\n          if (\r\n            pattern.timer[tmpIndex] === pattern.timer[tmpIndex + 1] &&\r\n            tmpIndex < pattern.timer.length\r\n          ) {\r\n            tmpIndex = Math.min((tmpIndex += 1), pattern.timer.length);\r\n            loop += 1;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // add to products list\r\n        for (let i = 0; i < loop; i++) {\r\n          if (i > 0) {\r\n            index = Math.min((index += 1), pattern.timer.length);\r\n          }\r\n          timer = worldState.stateTime + pattern.timer[index];\r\n\r\n          // TODO: get random product\r\n          let isFake = true;\r\n          let randomProduct = Math.floor(Math.random() * fakeProductTex.length);\r\n          if (Math.random() > 0.3) {\r\n            isFake = false;\r\n            randomProduct = Math.floor(Math.random() * productTex.length);\r\n          }\r\n\r\n          products.push({\r\n            // type: randomProduct,\r\n            type: 2,\r\n            // isFake,\r\n            stateTime: 0,\r\n            x: pattern.x[xIndex],\r\n            y: -height / 8,\r\n            speedY: 0,\r\n          });\r\n\r\n          xIndex = Math.min((xIndex += 1), pattern.x.length - 1);\r\n        }\r\n\r\n        if (index === pattern.timer.length) {\r\n          delayTime =\r\n            worldState.stateTime + getDelayBaseOnDifficulty(difficulty);\r\n          index = 0;\r\n          xIndex = 0;\r\n          pattern = undefined;\r\n        }\r\n      }\r\n    },\r\n  };\r\n};\r\n\r\nexport default createProductSpawnSystem;\r\n"]},"metadata":{},"sourceType":"module"}